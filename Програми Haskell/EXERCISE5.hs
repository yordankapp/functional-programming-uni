

-- (flatten '(1 2 3))
--(flatten '(1 (2 3) (3 (4 (5)))))

data Nested a = Empty | Value a | List [Nested a] deriving Show
flatten :: Nested a -> [a]
flatten Empty =[]
flatten (Value x) =[x]
flatten (List xs) = foldl (\ res ns -> res ++ flatten ns) [] xs

ts::Nested Int
ts = List [Value 1,
            List [Value 2, Value 3],
            List [Value 3, List [Value 4, List [Value 5]]]]


-- Задача 4.1 Дефинирайте функция findMinTime :: Int -> [Int] -> Int, която получава два параметъра:
-- брой k на идентични машини и списък ds с n на брой цели числа, съответстващи на необходимото време 
-- за изработване на n на брой детайла. Функцията трябва да върне минималното време за изработката на всички
--  детайли при условие, че машините работят едновременно.

-- Задача 4.2 Да се напише функция assignJobs :: Int -> [[Int]] -> Int, която получава два параметъра:
--  брой k на задачи и списък es с n на брой подсписъка. Всеки от n-те подсписъка на es съответства на даден
--   работник и съдържа номерата на задачите, които той може да изпълни. Задачите в подсписъците на es са 
--   индексирани от 1 до k включително. Не всеки работник може да изпълни всяка задача. Всеки работник може да 
--   изпълни най-много една задача и всяка задача трябва да се изпълни от точно един работник. Функцията трябва
--    да върне максималния брой на работниците, които ще получат задача.

main = do
    print $ flatten ts
